Разработка задач "--- это процесс, который происходит задолго до самого соревнования, и его цель "--- подготовить корректные тесты, учитывающие все частные случаи задач. Тестов может быть много, и входные данные каждого из них могут иметь большой размер, поэтому для их генерации пишутся специальные программы "--- генераторы. Для того, чтобы проверить, что входные данные того или иного теста корректны для данной задачи, пишутся валидаторы. Чекеры используются для того, чтобы проверять, являются ли выходные данные верными, в тех случаях, когда у задачи может быть много правильных ответов. И, наконец, интеракторы используются в интерактивных задачах, где программа-решение участника может общаться с тестирующей системой, следуя определённому формату ввода-вывода. Последние, впрочем, встречаются нечасто, поэтому мы не будем рассматривать их в нашей работе.

Каждое описанное средство "--- в свою очередь тоже программа. Очевидно, что в каждой из них для многих олимпиадных задач приходится выполнять множество похожих операций. Это подразумевает, что в данном случае целесообразно использование специальной библиотеки, предоставляющей удобные средства для решения типичных задач. Одной из таких библиотек является testlib.h \cite{testlib}, написанная на языке C++. Именно на её характеристики мы будем опираться при рассмотрении средств разработки задач и в дальнейшем при их написании.

\subsection*{Тесты}

Каждый тест представляет собой по крайней мере два файла: входные данные и эталонные выходные данные, предложенные жюри. Почти всегда тесты объединяются в группы, по тем или иным критериям. Это делается, например, для того, чтобы за тесты из разных групп начислять различное количество очков, или чтобы засчитывать тесты из группы только в том случае, когда правильный ответ был получен по всем тестам в группе.

Из всех групп тестов выделяются две, имеющие особое значение: тесты из условия задачи (samples) и претесты (pretests). Тесты из первой группы, в отличие от всех остальных тестов, известны участникам, поскольку содержатся в выданных им условиях задач. Участникам известны как входные данные, так и эталонные выходные данные. Именно используя такие тесты, они могут тестировать свои решения во время соревнования. Как правило, если решение даёт неверный ответ хотя бы на одном тесте из условия, на остальных тестах решение уже не запускается, и за задачу не начисляются очки.

Претесты "--- это тесты, на которых тестируются решения непосредственно во время соревнования. В зависимости от правил проведения соревнования может быть так, что во время соревнования тестирование идёт на всех тестах сразу (например, в ICPC \cite{wiki}), тогда все тесты можно считать претестами. Но в других ситуациях (например, в IOI \cite{wiki} или в контестах на платформе Codeforces \cite{codeforces}) на большей части тестов решения проверяются уже после соревнования, во время так называемого системного тестирования. Это делается для того, чтобы во время соревнования нагружать систему меньшим количеством работы.

Когда сгенерированы входные данные по всем тестам, необходимо также представить эталонные выходные данные жюри. Это делается, как правило, при помощи авторских решений. Автор задачи пишет собственную программу, которая, по его мнению, даёт верные ответы на всех возможных тестах, а затем она запускается для всех входных данных, и полученные выходные данные принимаются как эталонные. Иногда случается так, что во время соревнования в авторском решении находится ошибка, в таких случаях задача считается некорректной, и за неё никому не начисляются очки.

\subsection*{Генераторы}

Как уже говорилось ранее, входные данные тестов могут быть очень большими, и далеко не всегда их можно написать вручную. В таких случаях пишутся специальные программы "--- генераторы. Ясно, что при их написании удобно пользоваться уже написанными функциями, выполняющими типичные для генераторов задачи.

Важно, что генераторы, несмотря на простоту их задачи, должны удовлетворять некоторым требованиям. Например, <<генератор должен выводить один и тот же тест при компиляции любым компилятором на любой платформе, если он запущен одинаковым способом>> \cite{testlib}. Это означает, что, во-первых, нельзя использовать стандартные генераторы псевдослучайных чисел, не инициализируя их конкретным значением, потому что так каждый новый вызов генератора будет выдавать разные тесты. И, во-вторых, это значит, что лучше переложить все хлопоты по генерации псевдослучайных значений на используемую библиотеку, чтобы не задумываться об их генерации в момент написания генератора и чтобы библиотека сама обеспечивала однозначность вывода и независимость его от платформы и компилятора.

Таким образом, будет удобно разместить в библиотеке генератор псевдослучайных чисел (для их генерации сойдёт простой линейный конгруэнтный метод), а также "--- предоставить методы для получения, например, целых или дробных чисел из определённого диапазона, символов, удовлетворяющих некоторому шаблону, и т. д.

Кроме того, важно, чтобы генератор был строг к формату выводимого теста, то есть важно, чтобы, например, между числами, символами или словами был только один пробел, чтобы не было лишних пробелов по краям строк, чтобы переводы строки были там, где это ожидается, и чтобы весь тест заканчивался переводом строки. Для того, чтобы это обеспечить, также удобно будет разместить в библиотеке методы для удобного вывода.

Также важно, чтобы генератор мог принимать извне некоторые параметры, например, в виде строковых значений. Это нужно для того, чтобы можно было один и тот же генератор запускать несколько раз с разными входными параметрами и получать различные тесты, удовлетворяющие различным условиям.

\subsection*{Валидаторы}

Валидаторы нужны для того, чтобы проверять, что сгенерированные или написанные вручную входные данные для некоторой задачи корректны, то есть удовлетворяют требованиям из условия задачи. Например, может оказаться, что некоторая величина во входных данных превышает допустимое ограничение, или описанный граф не является связным. Подобные вещи может быть сложно оценить с одного взгляда на тест, особенно если входные данные "--- большой файл, созданный генератором. Поэтому, несмотря на то, что валидация тестов, по сути, необязательна, ведь и без неё можно получить корректные тесты и запускать на них решения, проведение валидации настоятельно рекомендуется \cite{testlib}. Более того, написание валидаторов "--- обязательная процедура перед многими контестами, например, перед раундами на платформе Codeforces \cite{codeforces}.

Важно, что валидатор так же, как и генератор, должен быть строг к формату входных данных. Он должен проверять не только то, как расставлены пробелы и переводы строк, но и формат чисел и символов, а в случае какого-либо несовпадения с тем, что ожидалось, выводить удобочитаемое сообщение об ошибке.

Ясно, что в библиотеку разработки задач удобно добавить специальные методы для считывания составных частей входного файла, выполняющие операции вроде следующих: <<прочесть целое число>>, <<прочесть пробел>>, <<прочесть перенос строки>>, <<прочесть конец файла>> и т. д. Полезными могут оказаться также методы проверки, удовлетворяет ли символ или строка некоторому шаблону. Кроме того, удобны методы, позволяющие автоматически сообщать об ошибке, если не выполняется то или иное условие.

Наконец, валидатор так же, как и генератор, должен уметь принимать некоторые параметры, чтобы затем использовать их в своей работе. Это может пригодиться, например, если в разных группах тестов входные данные должны удовлетворять различным ограничениям. Тогда получится использовать один и тот же валидатор с разными параметрами для разных групп тестов.

\subsection*{Чекеры}

Как упоминалось ранее, чекеры используются в тех случаях, когда задача имеет множество правильных ответов. Например, в задаче может требоваться вывести описание графа, удовлетворяющего некоторому требованию, или найти кратчайший путь в графе, который также в общем случае может быть не единственным. В таких случаях недостаточно просто сравнить ответ участника с эталонным ответом жюри, поэтому пишутся специальные программы "--- чекеры, которые выполняются непосредственно в момент перед выносом вердикта по посылке и сообщают тестирующей системе о результате проверки.

Чекер должен принимать на входе три потока ввода: для тестовых входных данных, для ответа участника и для ответа жюри. В процессе своего выполнения чекер должен считать и проанализировать данные из каждого потока. При этом чекеру уже не нужно проверять правильность формата тестовых входных данных, потому что эту работу за него уже выполнил ранее валидатор. Следует проверять формат ответа участника, а заодно "--- и ответа жюри.

По итогам своей работы чекер должен вынести вердикт. Чекер может сделать это разными способами. Например, вывести результат в стандартный вывод, в некоторый xml-файл или как-то ещё. В зависимости от реализации и требований к системе можно выделить разные возможные вердикты, мы выделим три основных:

\begin{itemize}
\item OK "--- означает, что программой участника был получен правильный ответ, соответствующий необходимому формату вывода;
\item WRONG ANSWER "--- означает, что программа участника либо вывела неправильный ответ, либо вывела данные, не соответствующие требуемому формату;
\item FAIL "--- означает, что при работе чекера произошла непредвиденная ошибка, либо что участником было найден корректный ответ, более оптимальный, чем ответ жюри.
\end{itemize}

Важно, что код чекера также должен удовлетворять определённым требованиям. Во-первых, он не должен предполагать, что ответ жюри абсолютно верен и не подлежит сомнению. То есть если программа участника нашла некоторый формально корректный ответ, который оказался оптимальнее ответа жюри, чекер обязан об этом сообщить. Это должно происходить как раз в том случае, когда в авторском решении была допущена ошибка. Во-вторых, в чекере следует избегать дублирования кода, вынося код считывания ответа в отдельную функцию, чтобы в ней можно было считать как ответ участника, так и ответ жюри. Чекер, написанный таким образом, обычно оказывается короче и проще для понимания и, кроме того, позволяет проверить одновременно формат и ответа участника, и ответа жюри.

Разумеется, в чекере также используется множество операций, которые удобно выполнять, вызывая методы из библиотеки. К таким операциям можно отнести многие операции, которые ранее уже упоминались в разделе о валидаторах, поскольку в чекере часто происходят схожие процессы. Отличие будет состоять в том, что считывание данных из файлов в чекере не должно быть таким строгим, как в валидаторе, поскольку формат выходных данных обычно менее строг. Например, лишние пробелы в выводе не будут критичны, так же, как и перенос строки вместо ожидаемого пробела.